Основной дизайн отладчика RR строится вокруг двух взаимодополняющих компонентов
— механизмов записи (Record) и воспроизведения (Replay). Поговорим подробнее
про каждый из этих компонентов.


\subsection{Record-and-Replay: способ записи и воспроизведения}

% Задача Record — 
% сохранить некую часть информации об исполнении программы и ее используемых данных, 
% необходимую для того, чтобы в дальнейшем 
% точно воспроизвести поведение записываемой программы.

% Задача Replay — 
% воспроизвести исполнение программы, сохраненное в ходе процесса записи, 
% чтобы получить результаты, которые были получены во время записи.

% Система RR ставит выполнение данных задач для программы 
% с минимальными накладными расходами, без внесения каких-либо низкоуровневых изменений в 
% окружение и используя лишь нативные возможности, предоставляемые операционной системой.


\begin{itemize}

  \item \textbf{Концепция Record}
  
  Когда RR запускает программу в режиме записи, то он делает следующее:
    \begin{enumerate}
      \item \textbf{Наблюдение за взаимодействием с внешним миром:}

        Программа постоянно общается с операционной системой: читает файлы, отправляет
        данные по сети, получает текущее время, реагирует на ввод пользователя и т.д.
        Эти взаимодействия могут давать разные результаты при каждом запуске. RR
        тщательно следит за каждым таким обращением программы к ''внешнему миру'' (к ядру
        ОС) и аккуратно записывает: 
          \begin{itemize}
            \item Что программа попросила? (Например, ''прочитать 100 байт из файла X'').
            \item Что ей ответил внешний мир? (Например, ''вот эти 100 байт'' или ''ошибка, файл не найден'').
                  Все эти ответы и данные записываются.
          \end{itemize} 

      \item \textbf{Фиксация ''поворотных моментов'' во времени:}

      В программе могут происходить события, время которых заранее неизвестно:
        \begin{itemize}
          \item \textbf{Сигналы:} Внезапные уведомления от операционной системы (например, Ctrl+C или ошибка в другом процессе). 
                RR записывает, какой именно сигнал пришел и в какой момент выполнения программы это случилось.

          \item \textbf{Работа с потоками (threads):} 

          Если программа многопоточная, порядок, в котором потоки получают процессорное время и взаимодействуют друг с другом 
          (через общую память, синхронизацию и т.д.), может меняться от запуска к запуску. RR старается упорядочить эту работу или, как минимум, 
          очень точно зафиксировать, какой поток сколько ''поработал'', прежде чем управление перешло к другому потоку или произошло
          какое-то внешнее событие. Он записывает эту последовательность переключений и ''объем работы'', выполненный каждым потоком между 
          этими переключениями.

          \item \textbf{Отслеживание некоторых внутренних непредсказуемостей:}

          Некоторые процессорные инструкции могут давать разные результаты (например, чтение счетчика тактов). 
          RR также старается зафиксировать результаты таких операций.
        \end{itemize}

        В итоге получается некий ''лог'' (журнал) всех внешних воздействий и внутренних непредсказуемых событий, 
        а также точных моментов, когда они произошли, относительно ''внутреннего времени'' программы, 
        который можно использовать для воспроизведения программы.
    
    \end{enumerate}
  
  \item \textbf{Концепция Replay}

    Теперь, имея этот детальный лог, RR может запустить программу снова, но уже в совершенно других условиях:
    \begin{enumerate}

      \item \textbf{Изоляция от реального внешнего мира:} 
      
      Когда программа во время
      воспроизведения пытается снова обратиться к операционной системе (прочитать
      файл, получить время и т.д.), RR перехватывает этот запрос. Вместо того чтобы
      обращаться к реальной ОС, RR заглядывает в свой записанный лог и говорит
      программе: ''В прошлый раз, когда ты просила это, тебе ответили вот так\ldots''. И
      подсовывает ей те же самые данные или тот же самый код ошибки, который был во
      время записи. Программа ''думает'', что общается с реальным миром, но на самом
      деле получает ответы из прошлого.

      \item \textbf{Воссоздание последовательности событий:}
      
      \begin{itemize}

        \item \textbf{Сигналы:} RR следит за ходом выполнения программы. Когда программа
        доходит до того ''момента'' (измеренного по ее ''внутреннему времени'', как
        при записи), когда в оригинальном запуске пришел сигнал, RR
        искусственно доставляет ей точно такой же сигнал.

        \item \textbf{Работа с потоками:} RR использует записанную информацию о
        переключениях и ''объеме работы'' потоков, чтобы заставить их выполняться
        в точно такой же последовательности и с такими же интервалами, как это
        было при записи. Никакой ''случайности'' в планировании потоков больше
        нет.

      \end{itemize}

    \item \textbf{Повторение внутренних непредсказуемостей:}

      Если программа обращается к инструкции, результат которой был записан, RR предоставляет ей этот сохраненный результат.

    \end{enumerate}

    В итоге программа выполняется \textbf{абсолютно идентично} тому, как она
    выполнялась во время записи.

\end{itemize}

\subsection{Ограничения многопоточного исполнения}

% В системе RR используется модель записи исполнения потоков N:1. Это означает, 
% что из всех N имеющихся потоков, одновременно исполняться и, соответственно, записываться, будет лишь один поток.
% Причина такого решения в сложности 
% контроля исполнения многопоточных программ. Во время записи из-за многопоточности некоторые данные могут быть либо записаны некорректно, 
% либо вовсе потеряны, что недопустимо. Во время воспроизведения требуется корректная синхронизация потоков, 
% добиться которой может быть сложно.

% Несмотря на решение большинства проблем с многопоточностью, этот подход приводит к ограничениям в определении 
% некоторых многопоточных ошибок, таких как \textit{deadlock}, \textit{starvation}, \textit{liveness} и т.п.


\textbf{Многопоточные ограничения при записи:}

Когда RR записывает многопоточное приложение, он, по сути, берет на себя
значительную часть функций планировщика ОС, но только для потоков целевого
процесса.
\begin{itemize}

  \item \textbf{Снижение истинного параллелизма:} Вместо того чтобы позволить
  ядру ОС свободно планировать потоки приложения по доступным CPU-ядрам, RR
  обычно \textbf{ограничивает их выполнение одним ядром} и сам решает, какой
  поток будет выполняться следующим. Эмуляция работы на одном ядре означает,
  что программа во время записи не использует всю мощь многоядерного
  процессора.

  \item \textbf{Выбор конкретного сценария планирования:} RR записывает один
  конкретный сценарий взаимодействия потоков, который случился во время сессии
  записи. Он не пытается исследовать все возможные сценарии.

\end{itemize}

\textbf{Многопоточные ограничения при воспроизведении:}

Во время воспроизведения RR использует свой лог, чтобы заставить потоки вести себя идентично.

\begin{itemize}

  \item \textbf{Воспроизводится только записанный сценарий:} Если ошибка
  синхронизации (например, гонка данных) не проявилась во время конкретной
  сессии записи (из-за того, как rr упорядочил потоки), она не проявится и при
  воспроизведении этой записи. Для ее поимки может потребоваться несколько
  попыток записи или специфические условия.

\end{itemize}

В целом, RR для многопоточности создает управляемую, детерминированную среду, фиксируя одно из возможных поведений системы
% \subsection{Детерминизм}

% При воспроизведении любой произвольной записанной программы необходимо воспроизвести ее в точном совпадении. 
% Это означает, что требуется линеаризовать или же точно определять ход исполнения программы в каждый момент времени.
% Это не такая простая задача, как может показаться на первый взгляд, 
% так как детерминизм должен поддерживаться за счет контроля со стороны пользовательской программы, 
% не имеющей доступа к большинству возможностей ядра ОС.
% Конкретный способ реализации будет рассмотрен далее.
