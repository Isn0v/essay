% Проект RR доказал, что эффективная запись и воспроизведение выполнения пользовательских процессов возможны 
% на стандартном оборудовании (x86/x86-64) и ОС (Linux) без модификаций ядра или использования виртуальных машин. 
% Это открывает новые возможности для отладки сложных приложений (например, Firefox, Chromium) с низкими накладными расходами.
% С более подробными результатами тестирования можно ознакомиться в статье \cite{rr-paper}.

Разработка RR дебаггера основана на принципе \textbf{записи и детерминированного
воспроизведения} исполнения программы. На этапе \textbf{записи} RR перехватывает все
источники недетерминизма: системные вызовы (их аргументы и результаты
логируются, часто с помощью in-process syscall interception и syscall-буфера
для производительности), сигналы (время и тип доставки), а также
недетерминированные инструкции CPU вроде RDTSC. Все эти события и их исходы
записываются в детальный лог. На этапе \textbf{воспроизведения} RR заставляет программу
выполняться, но вместо реальных обращений к ОС или выполнения
недетерминированных инструкций, он ''подсовывает'' ей значения из этого лога,
точно воссоздавая первоначальное поведение. \textbf{Time-travel debugging}, включая
\textbf{reverse debugging}, реализуется поверх этого: ''перемотка вперед'' — это просто
воспроизведение до нужной точки, а ''шаг назад'' достигается не истинным обратным
исполнением, а восстановлением состояния программы из ранее сохраненного
\textbf{чекпоинта} (снимка памяти и регистров) и быстрым воспроизведением вперед с этого
чекпоинта до точки, непосредственно предшествующей желаемому моменту отката.

\textbf{Ключевые выводы разработки}: борьба с недетерминизмом — основная сложность;
производительность записи критична (требуются оптимизации вроде in-process
перехвата); воспроизведение эффективно за счет эмуляции syscall'ов по логу;
система получается сложной, хрупкой и сильно завязанной на ОС и архитектуру,
требуя баланса между полнотой покрытия и практической реализуемостью.