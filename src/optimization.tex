\subsection{Снижение места под данные логов}

% Простое копирование необходимых бинарников, исполняемых файлов и библиотек быстро раздует память, 
% поэтому вместо этого создаются жесткие ссылки 
% на все необходимые файлы.

% Также, современные файловые системы (\texttt{XFS}\footnote{\url{https://ru.wikipedia.org/wiki/XFS}})
% поддерживают механизм \texttt{COW}\footnote{\url{https://en.wikipedia.org/wiki/Copy-on-write}} (copy-on-write). 
% RR просто клонирует нужные области в каталоге трэйса (записанного наблюдаемого потока), не тратя почти места и времени. 
% Фактическое копирование произойдёт лишь в случае модификации исходного файла.

Цель RR – записать ровно столько информации, сколько необходимо для точного
детерминированного воспроизведения. Какие вопросы нужно решить:

\begin{itemize}

  \item Между двумя событиями, которые RR должен зафиксировать (например, двумя
  системными вызовами или сигналом), программа может выполнить миллионы
  инструкций. Если эти инструкции не взаимодействуют с внешним миром и их
  поведение полностью предсказуемо, то нет смысла записывать состояние
  программы после каждой из них. Это достигается за счет упомянутых выше
  \textbf{аппаратных счетчиков производительности (HPC)}, которые позволяют RR
  ''пролетать'' с точки зрения логирования большие участки кода, где ничего
  недетерминированного не происходит.

  \item Представьте системный вызов \textbf{read()}, который просит прочитать 1 мегабайт
  данных из файла. Если в файле осталось только 10 килобайт, то будет прочитано
  именно 10 КБ. Если бы RR всегда резервировал в логе место под запрошенный 1
  МБ, лог бы быстро раздулся. 

  RR записывает в лог только те данные, которые фактически были переданы или
  изменены системным вызовом. В нашем примере с \textbf{read()}, если было прочитано 10
  КБ, то именно эти 10 КБ (и информация о том, что было прочитано 10 КБ) и
  попадут в лог. Это значительно экономит место, особенно для программ с
  активным файловым или сетевым \texttt{IO}.

  \item Файлы логов, создаваемые RR, часто автоматически сжимаются с
  использованием стандартных алгоритмов компрессии (например, с помощью
  \texttt{zlib} в deflate-формате).

\end{itemize}

% \subsection{Эмуляция системных вызовов}

% Во фазе Воспроизведения RR может вообще пропустить исполнение системного
% вызова. Для этого в трассируемом процессе ставится точка останова (breakpoint)
% перед входом в некоторый системный вызов. Когда трассируемый процесс
% останавливается, RR лишь ''подменяет'' состояние регистров на взятые из логов,
% записанных в фазе Записи, так, будто трассируемый процесс уже исполнил данный
% системный вызов. Далее RR возвращает управление в трассируемый процесс.


\subsection{In-process system call interception}

% Interception library — ключевая оптимизация в RR, позволяющая достичь низких накладных расходов за счёт минимизации взаимодействия с 
% \texttt{ptrace}.
% Она внедряется в каждый записываемый процесс, выполняет системные вызова, не вызывая
% \texttt{ptrace},
% и записывает результаты исполнения в специальный буфер, разделяемый с RR.
% В результате, с её помощью удается снизить количество смен контекста до с 2 до 0.

Это техника, при которой RR встраивает небольшой код непосредственно
в адресное пространство отлаживаемой программы (tracee) для перехвата системных
вызовов.

В память трассируемого процесса
инъецируется\footnote{\url{https://en.wikipedia.org/wiki/DLL_injection}}
специальный ''буфер системных вызовов'' (syscall buffer) и небольшой
код-обработчик (stub). Точки входа в системные вызовы (например, в
\texttt{libc}\footnote{\url{https://www.gnu.org/software/libc/}})
модифицируются так, чтобы вызывать этот инъецированный stub. Через syscall
buffer RR может взаимодействовать со stub, который в располагается в адресном
пространства трассируемого процесса.

В фазе Записи Stub записывает аргументы системного вызова в \texttt{syscall
buffer}. Затем он может либо выполнить оригинальный системный вызов прямо
внутри себя, либо сигнализировать RR (как трассировщику), который затем через
ptrace даст команду на выполнение. После выполнения результат также
записывается.

В фазе Воспроизведения Stub записывает ''намерение'' вызвать syscall в буфер.
Основной процесс RR видит это, находит в логе записанный ранее результат этого
вызова и передает его обратно в stub. Stub эмулирует завершение syscall'а,
подставляя записанные значения (возвращаемое значение, данные в буферах).
Реальный системный вызов к ядру не происходит.

Из плюсов данной данной техники можно выделить:
\begin{itemize}

  \item \textbf{Снижение накладных расходов: } Вызов системного вызова через
  \texttt{ptrace} требует переключения контекста между процессами, что
  значительно замедляет выполнение. Используя in-process interception, RR может
  избежать этого переключения, что приводит к значительному увеличению
  производительности.

  \item \textbf{Гибкость: } Дает больше контроля над исполнением внутри
  процесса.

\end{itemize}

Из минусов можно отметить:

\begin{itemize}

  \item \textbf{Сложность: } Инъекция кода, его синхронизация с внешним
  трассировщиком, обработка пограничных случаев (сигналы, многопоточность) ---
  всё это очень непросто.

\end{itemize}

% \subsection{Оптимизация чтения с клонированием блоков}

% Если и трэйс, и входные данные находятся в одной файловой системе, поддерживающей copy-on-write, то в коде interception library 
% системного вызова \texttt{read} реализуется клонирование блоков в трэйс файл, свой для каждого наблюдаемого потока.



