% TODO: \subsection{Общие сведения}

\subsection{Ptrace}

\href{https://man7.org/linux/man-pages/man2/ptrace.2.html}{\texttt{Ptrace}} — системный вызов в Linux, позволяющий не только наблюдать за выполнением программы, 
но и контролировать его. Это ключевое средство, за счет которого 
достигается большинство возможностей RR.

\subsection{Модель потоков}

Как уже было сказано, в RR используется модель N:1 потоков как для записи, 
так и для воспроизведения. Основной причиной такого подхода заключается в сложности 
контроля исполнения многопоточных программ. Во время записи из-за многопоточности некоторые данные могут быть либо записаны некорректно, 
либо вовсе потеряны, что недопустимо. Во время воспроизведения требуется корректная синхронизация потоков, 
которой невозможно достичь при их одновременном исполнении.

Несмотря на решение большинства проблем с многопоточностью, этот подход приводит к ограничениям в определении 
некоторых многопоточных ошибок, таких как \textit{deadlock}, \textit{starvation}, \textit{liveness} и т.п.

\subsection{Контроль системных вызовов}

\href{https://man7.org/linux/man-pages/man2/ptrace.2.html}{\texttt{Ptrace}} дает хорошую вариативность в 
управлении пользовательских данных для наблюдаемого потока, 
а также в контроле исполнений системных вызовов внутри него. 
% Это работает так, что при входе в системный вызов поток останавливается и RR уведомляется, и когда RR решает возобновить поток, 
% то этот поток продолжает исполнение до тех пор, пока не заканчивает исполнение системного вызова, и уведомляет RR еще раз. 
Это удобно тем, что во время уведомлений можно сохранить и даже изменить состояние пользовательских данных. 
На рисунке \ref{fig:syscall} показан пример записи системного вызова \texttt{read}.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
      node distance=0.8cm and 2cm,
      every node/.style={draw, align=left, text width=4.5cm, font=\small, inner sep=3pt}
  ]
      % Заголовки
      \node (tracee) [fill=yellow!20, text width=3.5cm] {\textbf{Tracee thread}};
      \node (recorder) [fill=blue!20, text width=5cm, right=of tracee] {\textbf{Recorder thread}};
      
      % Левые узлы (Tracee)
      % \node (read) [below=of tracee] {read(fd, buf, size)};
      \node (notify1) [below=of tracee] {ptrace\_notify};
      \node (sysread) [below=of notify1] {sys\_read};
      \node (notify2) [below=of sysread] {ptrace\_notify};

      % Правые узлы (Recorder) с нужными строками
      \node (wait1) [below=of recorder] {waitpid(T) \\ \textit{redirect arg2 to scratch} \\ ptrace(T, CONT\_SYSCALL)};
      \node (wait2) [below=of wait1] {waitpid(T) \\ $N = \textit{syscall\_result\_reg}$ \\ save $N$ scratch bytes to trace \\ copy $N$ scratch bytes to buf \\ ptrace(T, CONT\_SYSCALL)};

      % Стрелки от Recorder -> Tracee (на нужные строки)
      \draw[->] ([yshift=-10pt] wait1.west) -- ++(-1,0) |- ([yshift=-2pt] notify1.east);
      \draw[->] ([yshift=-23pt] wait2.west) -- ++(-1,0) |- ([yshift=-2pt] notify2.east);

      % Стрелки от Tracee -> Recorder (на нужные строки)
      \draw[->] ([yshift=2pt] notify1.east) -- ++(1,0) |- ([yshift=10pt] wait1.west); % Указывает на 2-ю строку wait1
      \draw[->] ([yshift=2pt] notify2.east) -- ++(1,0) |- ([yshift=20pt] wait2.west); % Указывает на 3-ю строку wait2

  \end{tikzpicture}
  \caption{Процесс записи системного вызова}
  \label{fig:syscall}
\end{figure}

Есть еще проблемы, связанные системными вызовами:

\begin{itemize}
  \item Системные вызовы могут быть определены слишком произвольно (например, \href{https://man7.org/linux/man-pages/man2/ioctl.2.html}{\texttt{ioctl}}). %TODO: документация для примеров?
  Тогда нужно запоминать всевозможные варианты их поведения.
  \item Некоторые системные вызовы взаимодействуют с потоками или памятью (например, 
  \href{https://man7.org/linux/man-pages/man2/mmap.2.html}{\texttt{mmap}} и \href{https://man7.org/linux/man-pages/man2/execve.2.html}{\texttt{execve}}). 
  C каждым из них требуются собственный подход.
\end{itemize}

% Иногда нужно выполнять системные вызовы в контексте наблюдаемого потока, и здесь, также с помощью \texttt{ptrace}, допускается вариативность. 
% Самый непростой подобный сценарий — это когда нужно исполнить системный вызов с заранее определенными параметрами. 
% В таком случае RR просто определяет местоположение необходимых параметров для нужного системного вызова, временно подменяет их 
% (допустимо как для параметров на стеке, так и в крайнем случае для параметров в адресном пространстве) и возвращает в исходное состояние 
% как только системный вызов выполнится.

\subsection{Обработка недетерминированных инструкций}

Существуют инструкции, которые не имеют определенного поведения в зависимости от контекста исполнения 
(например, 
\href{https://ru.wikipedia.org/wiki/Rdtsc}{\texttt{RDTSC}}, 
\href{https://en.wikipedia.org/wiki/RDRAND}{\texttt{RDRAND}}, 
\href{https://en.wikipedia.org/wiki/CPUID}{\texttt{CPUID}} и т.д.). Все они требуют собственного подхода к их обработке.


\subsection{Асинхронные события: контроль и обработка}

Есть два типа асинхронных событий, которые RR должен поддерживать: смена контекста и сигналы.
Эмуляция их срабатываний будет происходить через специальную смену контекста между наблюдателем и наблюдаемым посредством отправки 
сигнала наблюдаемому потоку. Важно, чтобы во время воспроизведения эти события срабатывали точно в тот же момент, 
в который они возникли во время записи, то есть когда сигнал был доставлен, состояние исполняющегося потока должно быть идентичным.
Об этом в следующей секции.

Во время обработки, когда RR переходит в обработчик сигнала, он записывает содержимое фрейма стека и регистров, установленных ядром. 
Во время воспроизведения, никакие обработчики не исполняются и никакие сигналы не доставляются по стандартной схеме. 
Вместо этого, RR просто вставляет записанные данные.

\subsection{Детерминация смены контекста}

Эмуляция смены контекста должная произойти ровно в тот момент, когда она произошла во время записи.
Соответственно, чтобы этот момент зафиксировать, 
нужно использовать какие-то данные, которые однозначно определят этот момент. 
Проблема заключается в том, что большинство поддерживаемых счетчиков в Linux 
не удовлетворяют этому условию по разным причинам. 
Например, некоторые значения счетчиков могут отличаться от одного воспроизведения к другому 
из-за содержания кэшей или спекулятивного исполнения инструкций в процессоре.

Тем не менее, современные процессоры на базе Intel имеют поставщик детерминированных данных — счетчик производительности 
"количества отработанных ветвлений" \@ (\texttt{RCB}). % https://en.wikipedia.org/wiki/Branch_predictor ?
Все же, нельзя полагаться исключительно на него во время определения вызова события как 
минимум потому, что важна конкретная инструкция, после которой сработало событие во время записи. 
Следовательно, к счетчику добавляется еще 
записанное состояние регистров. 
В большинстве случаев достаточно регистров общего назначения, но иногда записывается также состояние стека.
