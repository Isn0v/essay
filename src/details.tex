% TODO: \subsection{Общие сведения}

\subsection{Ptrace}

% TODO: ссылка на документацию, более подробное описание?
Ptrace — системный вызов в Linux, позволяющий не только наблюдать за выполнением программы, 
но и контролировать его. Это ключевое средство, за счет которого 
достигается большинство возможностей RR.

\subsection{Модель потоков}

Как уже было сказано, в RR используется модель N:1 потоков как для записи, 
так и для воспроизведения. Основной причиной такого подхода заключается в сложности 
контроля исполнения многопоточных программ. Во время записи из-за многопоточности некоторые данные могут быть либо записаны некорректно, 
либо вовсе потеряны, что недопустимо. Во время воспроизведения требуется корректная синхронизация потоков, 
которой невозможно достичь при их одновременном исполнении.

Несмотря на решение большинства проблем с многопоточностью, этот подход приводит к ограничениям в определении 
некоторых многопоточных багов, таких как \textit{deadlock}, \textit{starvation}, \textit{liveness} и т.п.

\subsection{Контроль системных вызовов}

% TODO: убрать текстовое описание и добавить диаграмму как в оригинальной статье
\texttt{Ptrace} дает хорошую вариативность в управлении пользовательских данных для наблюдаемого потока, а также в контроле исполнений 
системных вызовов внутри него. Когда поток входит или выходит из системного вызова, RR, как наблюдатель, уведомляется об этом. 
Это работает так, что при входе в системный вызов поток останавливается и RR уведомляется, и когда RR решает возобновить поток, 
то этот поток продолжает исполнение до тех пор, пока не заканчивает исполнение системного вызова, и уведомляет RR еще раз. 
Это удобно тем, что во время уведомлений можно сохранить и даже изменить состояние пользовательских данных.

Есть еще проблемы, связанные системными вызовами:

\begin{itemize}
  \item Системные вызовы могут быть определены слишком произвольно (например, \texttt{ioctl}). %TODO: документация для примеров?
  Тогда нужно запоминать всевозможные варианты их поведения.
  \item Некоторые системные вызовы взаимодействуют с потоками или памятью (например, \texttt{mmap} и \texttt{execve}). 
  C каждым из них требуются собственный подход.
\end{itemize}

% Также, предполагается, что можно эффективно определить состояние данных перед и после системного вызова. 
% Другими словами, поведение любого системного вызова должно быть детерминированным. На практике это не всегда так.

% Например, системный вызов \texttt{ioctl}. Его проблема в том, что его поведение зависит от ассоциированного с ним I/O устройства. В таком случае, 
% его модель строится на основе большого количества вариантов его поведения. Такой подход требует время от времени поддержку все новых I/O устройств.

% Иногда нужно выполнять системные вызовы в контексте наблюдаемого потока, и здесь, также с помощью \texttt{ptrace}, допускается вариативность. 
% Самый непростой подобный сценарий — это когда нужно исполнить системный вызов с заранее определенными параметрами. 
% В таком случае RR просто определяет местоположение необходимых параметров для нужного системного вызова, временно подменяет их 
% (допустимо как для параметров на стеке, так и в крайнем случае для параметров в адресном пространстве) и возвращает в исходное состояние 
% как только системный вызов выполнится.

\subsection{Обработка недетерминированных инструкций}

Существуют инструкции, которые не имеют определенного поведения в зависимости от контекста исполнения 
(например, \texttt{RDTSC}, \texttt{RDRAND}, \texttt{CPUID} и т.д.). Все они требуют собственного подхода к их обработке.


\subsection{Асинхронные события: контроль и обработка}

Есть два типа асинхронных событий, которые RR должен поддерживать: смена контекста и сигналы.
Эмуляция их срабатываний будет происходить через специальную смену контекста между наблюдателем и наблюдаемым посредством отправки 
сигнала наблюдаемому потоку. Важно, чтобы во время воспроизведения эти события срабатывали точно в тот же момент, 
в который они возникли во время записи, то есть когда сигнал был доставлен, состояние исполняющегося потока должно быть идентичным.
Об этом в следующей секции.

Во время обработки, когда RR переходит в обработчик сигнала, он записывает содержимое фрейма стека и регистров, установленных ядром. 
Во время воспроизведения, никакие обработчики не исполняются и никакие сигналы не доставляются по стандартной схеме. 
Вместо этого, RR просто вставляет записанные данные.

\subsection{Детерминация смены контекста}

Эмуляция смены контекста должная произойти ровно в тот момент, когда она произошла во время записи.
Соответственно, чтобы этот момент зафиксировать, 
нужно использовать какие-то данные, которые однозначно определят этот момент. 
Проблема заключается в том, что большинство поддерживаемых счетчиков в Linux 
не удовлетворяют этому условию по разным причинам. 
Например, некоторые значения счетчиков могут отличаться от одного воспроизведения к другому 
из-за содержания кэшей или спекулятивного исполнения инструкций в процессоре.

Тем не менее, современные процессоры на базе Intel имеют поставщик детерминированных данных — счетчик производительности 
"количества отработанных ветвлений" (\texttt{RCB}). 
Все же, нельзя полагаться исключительно на него во время определения вызова события как 
минимум потому, что важна конкретная инструкция, после которой сработало событие во время записи. 
Следовательно, к счетчику добавляется еще 
записанное состояние регистров. 
В большинстве случаев достаточно регистров общего назначения, но иногда записывается также состояние стека.
