Реализация RR ориентирована на минимальное вмешательство в работу целевого
приложения и окружения, используя исключительно возможности, предоставляемые
современными процессорами и ОС Linux. Нужно понять, за счет чего это достигается.

\subsection{Ptrace}



\textbf{Ptrace\footnote{\url{https://man7.org/linux/man-pages/man2/ptrace.2.html}}
(process trace)} — системный вызов в Linux, который предоставляет одному
процессу (трассировщику, \texttt{`tracer'}) возможность контролировать и наблюдать за
выполнением другого процесса (трассируемого, \texttt{`tracee'}). Это ключевое средство,
за счет которого достигается большинство возможностей RR.

В его реализации нам важно:

\begin{enumerate}

  \item Трассировщик использует ptrace с определенным запросом (например,
  \texttt{PTRACE\_ATTACH} или \texttt{PTRACE\_TRACEME} при запуске), чтобы
  ''прикрепиться'' к трассируемому процессу. С этого момента ядро знает, что
  этот процесс находится под внешним контролем.

  \item Когда в трассируемом процессе происходит ''интересное'' событие
  (например, он входит в системный вызов, собирается получить сигнал, выполняет
  инструкцию точки останова), ядро \textbf{приостанавливает} выполнение
  трассируемого процесса. Затем ядро \textbf{уведомляет} трассировщика об этом
  событии, посылая ему сигнал (обычно, \texttt{SIGTRAP}).

  \item Если трассируемый процесс остановлен, трассировщик может использовать
  другие запросы к ptrace для \textbf{чтения/записи} регистров CPU трассируемого
  процесса или его памяти, а также для \textbf{управления его дальнейшим выполнением}
  (например, продолжить нормально, выполнить одну инструкцию, пропустить
  текущий системный вызов, инжектировать сигнал и т.д.).

\end{enumerate}

Именно за счет этого системного вызова RR способен перехватывать системные
вызовы, обрабатывать сигналы, управлять выполнением и получать доступ к памяти и
состоянию отслеживаемой программы.

Тем не менее, ptrace имеет свои ограничения и проблемы:

\begin{itemize}

  \item Каждое событие, перехватываемое ptrace (например, вход/выход из
  системного вызова, сигнал), требует как минимум двух переключений контекста:
  от трассируемого процесса к ядру, затем от ядра к трассировщику, и обратно.
  Это значительно замедляет выполнение трассируемого процесса, особенно если
  системных вызовов много.

  \item Сложно контролировать доступы к какому участку пользовательской памяти
  вне системных вызовов. Тут может помочь введение точек останова по данным или
  же небольшая модификация кода без изменения глобальных эффектов. В принципе,
  и тем и другим RR пользуется.

  \item Некоторые системные вызовы могут быть сложны для точного перехвата и
  эмуляции всех их побочных эффектов, особенно если они сильно завязаны на
  внутреннее состояние ядра, информация о котором недоступна через ptrace. RR
  решает это, фокусируясь лишь на том, что видит трассируемый процесс, а не на
  глобальном состоянии системы.

  \item Хотя концепция ptrace есть во многих \texttt{UNIX}-подобных системах, конкретная
  реализация, доступные запросы и их поведение могут немного отличаться, что
  усложняет создание полностью кроссплатформенных отладчиков, опирающихся
  только на ptrace. RR в основном сфокусирован на Linux.

\end{itemize}

\subsection{Контроль системных вызовов}

% \texttt{Ptrace} дает хорошую вариативность в 
% управлении пользовательских данных для наблюдаемого потока, 
% а также в контроле исполнений системных вызовов внутри него. 
% Это удобно тем, что во время уведомлений можно сохранить и даже изменить состояние пользовательских данных. 
% На рисунке \ref{fig:syscall} показан пример записи системного вызова \texttt{read}.

Для RR, точный контроль и контроль системных вызовов – это фундамент,
на котором строится вся система записи и воспроизведения. Ведь именно через
системные вызовы программа взаимодействует с недетерминированным внешним миром
(файловая система, сеть, ядро, другие процессы).

RR использует ptrace (в частности, его возможность останавливать процесс на
входе и выходе из системного вызова, обычно через \texttt{PTRACE\_SYSCALL}) для
полного контроля. В качестве примера, рассмотрим системный вызов \texttt{read}
на рисунке \ref{fig:syscall} (на нем отображена фаза Записи):

\begin{enumerate}

  \item \textbf{Фаза Записи (Record):}

    \begin{itemize}

      \item \textbf{Остановка перед вызовом:} Когда трассируемый процесс
      собирается выполнить системный вызов \texttt{sys\_read}, ptrace
      уведомляет RR, выступающим в роли трассировщика (Tracer Thread).
      Трассирующий процесс останавливается перед тем, как ядро начнет
      обрабатывать вызов.

      В этот момент RR до срабатывания уведомления узнает об остановке через
      \texttt{wait\_pid(T)}\footnote{\url{https://man7.org/linux/man-pages/man3/wait.3p.html}},
      считывает номер системного вызова и все его аргументы (из регистров, из
      памяти по указателям), выполняет \textbf{redirect arg2 to scratch}. Это
      важный момент: \textbf{arg2} для \texttt{read} – это указатель на буфер, куда
      будут читаться данные. RR может подменить этот указатель на свой
      собственный ''черновой'' (scratch) буфер. Это дает RR полный контроль над
      тем, куда ядро запишет данные, и позволяет избежать проблем с доступом к
      памяти трассируемого процесса или изменением этой памяти до того, как RR
      ее залогирует.

      Затем RR разрешает трассируемому процессу продолжить выполнение внутрь
      системного вызова, с помощью \textbf{ptrace(T, CONT\_SYSCALL)}.

      \item{\textbf{Остановка после вызова:}} После того как ядро завершило
      обработку системного вызова, но до того, как управление вернулось обратно
      в пользовательский код трассируемого процесса, ptrace снова останавливает
      трассируемый процесс и уведомляет RR.

      % RR считывает возвращаемое значение системного вызова (обычно из регистра
      % \texttt{rax}), считывает любые данные, которые системный вызов записал в
      % память процесса (например, данные, прочитанные read в тот самый `scratch'
      % буфер). Вся эта информация (аргументы, возвращаемое значение, измененные
      % данные в памяти) тщательно записывается в лог (trace).

      RR снова ждет \texttt{wait\_pid(T)}. Он получает результат \textbf{N =
      syscall\_result\_reg} (количество прочитанных байт). Затем \textbf{save N scratch
      bytes to trace} – эти N байт из ''чернового'' буфера сохраняются в лог. И
      очень важный шаг: \textbf{copy N scratch bytes to buf} – RR копирует данные из
      своего ''чернового'' буфера в оригинальный буфер трассируемого процесса.
      Теперь для процесса все выглядит так, как будто \texttt{read} выполнился
      совершенно нормально и записал данные в его буфер.

      RR разрешает трассируемому процессу продолжить обычное выполнение,
      используя \textbf{ptrace(T, CONT\_SYSCALL)}.

    \end{itemize}

  \item \textbf{Фаза Воспроизведения (Replay):}

  Когда программа при воспроизведении доходит до места, где ранее был системный
  вызов, RR (снова через ptrace) перехватывает эту попытку. \textbf{Ключевой
  момент:} RR \textbf{не позволяет} ядру выполнить этот системный вызов
  повторно. 
  
  Вместо этого RR обращается к своему логу (trace), находит запись об этом
  конкретном экземпляре системного вызова, \textbf{''подделывает''} результат,
  устанавливая регистр возвращаемого значения (например, \texttt{rax}) тем
  значением, которое было записано в логе. Если системный вызов при записи
  изменял память (как \texttt{read}), RR копирует записанные ранее данные из лога в
  соответствующие области памяти трассируемого процесса.

  Программа \textbf{продолжает} выполнение, ''думая'', что системный вызов только что
  успешно (или неуспешно, как было записано) завершился.

\end{enumerate}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
      node distance=0.8cm and 2cm,
      every node/.style={draw, align=left, text width=4.5cm, font=\small, inner sep=3pt}
  ]
      % Заголовки
      \node (tracee) [fill=yellow!20, text width=3.5cm] {\textbf{Tracee thread}};
      \node (recorder) [fill=blue!20, text width=5cm, right=of tracee] {\textbf{Tracer thread}};
      
      % Левые узлы (Tracee)
      % \node (read) [below=of tracee] {read(fd, buf, size)};
      \node (notify1) [below=of tracee] {ptrace\_notify};
      \node (sysread) [below=of notify1] {sys\_read};
      \node (notify2) [below=of sysread] {ptrace\_notify};

      % Правые узлы (Recorder) с нужными строками
      \node (wait1) [below=of recorder] {waitpid(T) \\ \textit{redirect arg2 to scratch} \\ ptrace(T, CONT\_SYSCALL)};
      \node (wait2) [below=of wait1] {waitpid(T) \\ $N = \textit{syscall\_result\_reg}$ \\ save $N$ scratch bytes to trace \\ copy $N$ scratch bytes to buf \\ ptrace(T, CONT\_SYSCALL)};

      % Стрелки от Recorder -> Tracee (на нужные строки)
      \draw[->] ([yshift=-10pt] wait1.west) -- ++(-1,0) |- ([yshift=-2pt] notify1.east);
      \draw[->] ([yshift=-23pt] wait2.west) -- ++(-1,0) |- ([yshift=-2pt] notify2.east);

      % Стрелки от Tracee -> Recorder (на нужные строки)
      \draw[->] ([yshift=2pt] notify1.east) -- ++(1,0) |- ([yshift=10pt] wait1.west); % Указывает на 2-ю строку wait1
      \draw[->] ([yshift=2pt] notify2.east) -- ++(1,0) |- ([yshift=20pt] wait2.west); % Указывает на 3-ю строку wait2

  \end{tikzpicture}
  \caption{Процесс записи системного вызова}
  \label{fig:syscall}
\end{figure}

Есть еще нюансы, связанные системными вызовами:

\begin{enumerate}
  
  \item Системные вызовы могут быть определены \textbf{слишком
  произвольно}\footnote{Системный вызов выполняется \textbf{слишком
  произвольно} означает, что его поведение полностью зависит от переданных ему
  аргументов, в частности от переданного кода команды и указателя на данные, то
  есть в зависимости от этих аргументов реализации данного системного вызова
  могут кардинально отличаться.} (например,
  \texttt{ioctl}\footnote{\url{https://man7.org/linux/man-pages/man2/ioctl.2.html}}).
  RR должен уметь для распространенных реализаций \texttt{ioctl} определять,
  какие области памяти являются входными, какие выходными, и
  записывать/воспроизводить их содержимое.

  \item Некоторые системные вызовы взаимодействуют с потоками или памятью
  (например,
  \texttt{mmap}\footnote{\url{https://man7.org/linux/man-pages/man2/mmap.2.html}}
  и
  \texttt{execve}\footnote{\url{https://man7.org/linux/man-pages/man2/execve.2.html}}):
  
  \begin{itemize}

    \item \textbf{mmap:} изменяет адресное пространство процесса. RR должен
    точно записать параметры mmap (адрес, размер, права доступа, флаги,
    дескриптор файла, смещение) и его результат (полученный адрес). При
    воспроизведении он должен эмулировать этот \texttt{mmap}, чтобы адресное
    пространство было идентичным (в частности, аллокация страницы на
    фиксированный адрес достигается с помощью флага \texttt{MAP\_FIXED}).

    \item \textbf{execve:} создает новую программу, с новым стеком, кучей, и
    сегментами данных. RR должен это зафиксировать, записать аргументы,
    окружение нового процесса и повторить то же поведение \texttt{execve}, что
    и во время записи, загружая те же данные.

  \end{itemize}

\end{enumerate}

% \subsection{Обработка недетерминированных инструкций}

% Существуют инструкции, которые не имеют определенного поведения в зависимости от контекста исполнения 
% (например, 
% \texttt{RDTSC}\footnote{\url{https://en.wikipedia.org/wiki/Rdtsc}}, 
% \texttt{RDRAND}\footnote{\url{https://en.wikipedia.org/wiki/RDRAND}}, 
% \texttt{CPUID}\footnote{\url{https://en.wikipedia.org/wiki/CPUID}} и т.д.). Все они требуют собственного подхода к их обработке.


\subsection{Контроль асинхронных событий}

% Есть два типа асинхронных событий, которые RR должен поддерживать: смена контекста и сигналы.
% Эмуляция их срабатываний будет происходить через специальную смену контекста между наблюдателем и наблюдаемым посредством отправки 
% сигнала наблюдаемому потоку. Важно, чтобы во время воспроизведения эти события срабатывали точно в тот же момент, 
% в который они возникли во время записи, то есть когда сигнал был доставлен, состояние исполняющегося потока должно быть идентичным.
% Об этом в следующей секции.

% Во время обработки, когда RR переходит в обработчик сигнала, он записывает содержимое фрейма стека и регистров, установленных ядром. 
% Во время воспроизведения, никакие обработчики не исполняются и никакие сигналы не доставляются по стандартной схеме. 
% Вместо этого, RR просто вставляет записанные данные.

Когда программа выполняется, на нее могут влиять события, происходящие в
непредсказуемые моменты – асинхронные события. Ключевыми из них для RR являются
системные сигналы и решения операционной системы о переключении между потоками
(смена контекста). Чтобы отладчик мог точно воспроизвести выполнение, он должен
не только знать, что произошло, но и когда именно это произошло с точки зрения
самой программы. Так как по принципу возникновения это одинаковые события, то
для удобства восприятия, далее, и то, и другое событие будем называть
\textbf{сигналами}.

\subsubsection{''Внутренние часы''}

Сигнал может прервать программу где угодно. Если мы просто запишем ''пришел
сигнал X'', этого будет недостаточно. При повторном запуске тот же сигнал может
прийти чуть раньше или чуть позже, застав программу в другом состоянии (с
другими значениями в регистрах, на другой инструкции), и ошибка либо не
воспроизведется, либо проявится иначе.

Поскольку сигнал может
прервать программу где угодно, непонятно, как измерить эту самую ''точку
выполнения'',. Нужны какие-то \textbf{''внутренние часы''}. Причем простого использования
системного времени будет недостаточно, потому что оно как минимум довольно
грубое и подвержено колебаниям.

Для реализации подобных ''внутренних часов'' инженерами Mozilla \cite{rr-paper}
были взяты счетчики производительности
(\texttt{HPC}\footnote{\url{https://en.wikipedia.org/wiki/Hardware_performance_counter}})
на базе современных процессоров Intel. Это специальные регистры процессора,
которые аппаратно считают всякие события, происходящие во время исполнения
программы. Среди них:

\begin{itemize}

  \item \textbf{Instructions retired:} количество выполненных инструкций. Это
  количество может быть как с учетом спекулятивных инструкций (то есть
  инструкций, выполненных процессором заранее, но результат исполнения которых
  может быть проигнорирован), так и без учета.

  \item \textbf{Retired conditional branches:} количество выполненных условных
  переходов (также может быть как с учетом спекулятивных ветвлений, так и без).
  Условным переходом считается команда, которая передаёт управление по другому
  адресу (на метку) только если выполняется определённое условие (например,
  такими командами являются \texttt{je}, \texttt{jl}, \texttt{jz} и т.д.). RR в
  основном используют именно этот счетчик в роли ''внутренних часов'', потому
  что, как показала практика, этот счетчик меньше всего подвержен влиянию
  состояния процессора, на которое RR не может повлиять, а именно содержание
  кэшей или спекулятивное исполнение инструкций. \textbf{Важно:} RR использует
  \texttt{RCB} \textbf{без спекулятивных ветвлений}, поскольку в противном
  случае этот счетчик будет увеличиваться даже в тех случаях, когда RR не может
  гарантировать, что условное ветвление произошло.

\end{itemize}

В режиме Записи, когда RR перехватывает сигнал, он немедленно считывает текущее
значение этих ''внутренних часов'' и записывает в лог тип сигнала, показание
''внутренних часов'' в этот момент, а также полное состояние регистров CPU и,
возможно, ключевые участки стека\footnote{Уточнение про сохранение ''состояние
стека'': По большей части под ним подразумевается сохранение значения регистров
\texttt{rsp} и \texttt{rbp} (они определяют текущий кадр стека) и
последовательности сохраненных регистров \texttt{rbp} (это адреса на фреймы
предыдущих функций, которые помогают определить стек вызовов).} (далее станет
ясно, почему это важно).

В режиме Воспроизведения RR также отслеживает показания ''внутренних часов''.
Как только они достигают значения, которое было записано в логах для данного
сигнала, RR останавливает программу, восстанавливает записанное состояние
регистров/стека и ''доставляет'' программе тот же самый сигнал. Это гарантирует,
что сигнал застанет программу в абсолютно идентичном состоянии.

\subsubsection{Ограничения счетчиков}


% Для реализации подобного детерминизма будут рассматриваться аппаратные счетчики производительности 
% (\texttt{HPC}\footnote{\url{https://en.wikipedia.org/wiki/Hardware_performance_counter}}).
% Конкретная проблема детерминизма заключается в том, что большинство поддерживаемых счетчиков в Linux 
% не удовлетворяют этому условию по разным причинам. 
% Например, некоторые значения счетчиков могут отличаться от одного воспроизведения к другому 
% из-за содержания кэшей или спекулятивного исполнения инструкций в процессоре.

% Тем не менее, современные процессоры на базе Intel имеют поставщик детерминированных данных — счетчик производительности 
% 'количества отработанных ветвлений'
% (\texttt{RCB}\footnote{\url{https://en.wikipedia.org/wiki/Branch_predictor}}). 
% Все же, нельзя полагаться исключительно на него во время определения вызова события как 
% минимум потому, что важна конкретная инструкция, после которой сработало событие во время записи. 
% Следовательно, к счетчику добавляется еще 
% записанное состояние регистров. 
% В большинстве случаев достаточно регистров общего назначения, но иногда записывается также состояние стека. 

Как уже было сказано, помимо значения ''внутренних часов'', RR также записывает
полное состояние регистров и иногда даже состояние стека. Для того, чтобы понять, зачем
так нужно, рассмотрим следующие примеры кода:

\begin{codelisting}[H]
  \begin{minted}{nasm}
    loop:
      mov eax, 1
      mov ebx, 2
      inc eax
      jmp loop
  \end{minted}
  \caption{Ассемблерный код с необходимостью записи регистров}
  \label{lst:good-loop}
\end{codelisting}

\begin{codelisting}[H]
  \begin{minted}{nasm}
    bar():
      push    rbp
      mov     rbp, rsp
      mov     DWORD PTR [rbp-4], 1    ; int a = 1;
      pop     rbp
      ret
    foo():
      push    rbp
      mov     rbp, rsp
      call    bar()
      call    bar()
      call    bar()
      pop     rbp
      ret
  \end{minted}
  \caption{Ассемблерный код с необходимостью записи регистров и стэка}
  \label{lst:multiple-calls}
\end{codelisting}

\begin{codelisting}[H]
\begin{minted}{nasm}
  loop:
    inc [address]
    jmp loop
\end{minted}
  \caption{Ассемблерный код с проблемой}
  \label{lst:bad-loop}
\end{codelisting}

Уже в листинге \ref{lst:good-loop} легко понять, что одних ''внутренних часов''
не достаточно для определения конкретной инструкции, поскольку здесь нет
условных ветвлений и данный счетчик вообще не изменится. Тем не менее, меняется
состояние регистров, которое нужно сохранить. Логично предположить, что одного
регистра \texttt{IP}, хранящего адрес смещения следующей инструкции, будет
достаточно. Но это не так, потому что в качестве контрпримера достаточно
рассмотреть любой цикл, который проходит несколько раз некоторую инструкцию
(например, \texttt{add eax, 1}). В каждый момент прохождения в цикле данной
инструкции регистр \texttt{IP} будет указывать на нее (так как адрес в памяти
тот же), а счетчик \texttt{RCB} не изменится (так как инструкция \texttt{jmp}
не является условным ветвлением). Однако, если бы мы сохранили состояние
регистра \texttt{eax}, то смогли бы определить конкретную итерацию цикла, на
которой нам нужно воспроизвести сигнал.

В листинге \ref{lst:multiple-calls} также не происходит изменения ''внутренних
часов'', так как переход в другую функцию (вызов \texttt{call} не является
условным ветвлением). Помимо этого, сохранения регистров будет недостаточно,
поскольку сведения лишь о регистрах и ''внутренних часах'' не позволят понять, какая
функция была вызвана. Чтобы однозначно определить функцию среди набора
идентичных, нужно хранить ключевые участки стека, потому что там гарантированно
есть различная информация, по которой можно отличить вызовы функций. Так, в
листинге \ref{lst:multiple-calls} на стеке будет храниться адрес возврата из
соответствующей функции \texttt{bar} в функцию \texttt{foo}, а именно на
соответствующую \texttt{call} инструкцию, адрес смещения которой отличается от
адреса двух других.

В листинге \ref{lst:bad-loop} не будет меняться ничего из выше перечисленного,
и, следовательно, вызовет проблемы. Тем не менее, в статье \cite{rr-paper}
упоминается, что на практике в большинстве случаев подобный сценарий возникает
очень редко, поскольку код, сгенерированный компилятором, почти всегда
взаимодействует со стеком (как минимум в прологе и эпилоге, и этого уже в
основном достаточно, чтобы однозначно определить конкретную функцию), однако
если он возникнет, то RR просто не сможет воспроизвести его корректно.